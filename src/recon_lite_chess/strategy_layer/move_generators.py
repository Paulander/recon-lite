"""Strategic plan to move mapping.

This module provides move generators for each strategic plan,
allowing phase-aware move selection based on plan priorities.

Each generator returns a list of candidate moves with scores,
which are then combined with plan weights for final selection.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple, Dict, Any
import random

import chess


# Center squares for control evaluation
CENTER_SQUARES = [chess.D4, chess.D5, chess.E4, chess.E5]
EXTENDED_CENTER = CENTER_SQUARES + [
    chess.C3, chess.C4, chess.C5, chess.C6,
    chess.D3, chess.D6, chess.E3, chess.E6,
    chess.F3, chess.F4, chess.F5, chess.F6,
]


@dataclass
class PlanMoveCandidate:
    """A move candidate generated by a strategic plan."""
    move: chess.Move
    plan_id: str
    plan_weight: float
    move_score: float  # How well this move serves the plan (0-1)
    
    @property
    def final_score(self) -> float:
        """Combined score: plan weight Ã— move quality."""
        return self.plan_weight * self.move_score


def get_moves_for_plan(
    board: chess.Board,
    plan_id: str,
    plan_weight: float = 1.0,
) -> List[PlanMoveCandidate]:
    """
    Get candidate moves for a strategic plan.
    
    Args:
        board: Current board position
        plan_id: Strategic plan ID
        plan_weight: Weight of this plan (from phase adjustment)
        
    Returns:
        List of PlanMoveCandidate objects
    """
    generators = {
        "Develop": get_development_moves,
        "Castle": get_castling_moves,
        "CenterControl": get_center_control_moves,
        "AttackKing": get_attack_king_moves,
        "Simplify": get_simplify_moves,
        "ConvertAdvantage": get_simplify_moves,  # Similar to Simplify
        "CreatePassedPawn": get_pawn_advance_moves,
        "KingActivation": get_king_activation_moves,
        "WinMaterial": get_capture_moves,
        "DefendWeakness": get_defensive_moves,
        "CreateWeakness": get_weakness_moves,
        "ImproveWorstPiece": get_improvement_moves,
    }
    
    generator = generators.get(plan_id)
    if generator is None:
        return []
    
    moves_with_scores = generator(board)
    
    return [
        PlanMoveCandidate(
            move=move,
            plan_id=plan_id,
            plan_weight=plan_weight,
            move_score=score,
        )
        for move, score in moves_with_scores
    ]


def get_development_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that develop minor pieces from starting squares.
    
    Returns list of (move, score) tuples.
    """
    results = []
    turn = board.turn
    back_rank = 0 if turn == chess.WHITE else 7
    
    # Starting squares for minor pieces
    knight_starts = [chess.B1, chess.G1] if turn == chess.WHITE else [chess.B8, chess.G8]
    bishop_starts = [chess.C1, chess.F1] if turn == chess.WHITE else [chess.C8, chess.F8]
    
    for move in board.legal_moves:
        piece = board.piece_at(move.from_square)
        if not piece:
            continue
        
        score = 0.0
        
        # Knight development from starting square
        if piece.piece_type == chess.KNIGHT and move.from_square in knight_starts:
            score = 0.8
            # Prefer center-adjacent squares
            if move.to_square in EXTENDED_CENTER:
                score = 1.0
        
        # Bishop development from starting square
        elif piece.piece_type == chess.BISHOP and move.from_square in bishop_starts:
            score = 0.75
            # Prefer active diagonals
            if move.to_square in EXTENDED_CENTER:
                score = 0.95
        
        # Moving pieces off back rank (general development)
        elif chess.square_rank(move.from_square) == back_rank:
            if piece.piece_type in [chess.KNIGHT, chess.BISHOP]:
                score = 0.6
        
        if score > 0:
            results.append((move, score))
    
    return results


def get_castling_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get castling moves and moves that prepare for castling.
    
    Returns list of (move, score) tuples.
    """
    results = []
    turn = board.turn
    
    # Check for actual castling moves
    for move in board.legal_moves:
        if board.is_castling(move):
            # Kingside castling preferred (usually safer)
            score = 1.0 if board.is_kingside_castling(move) else 0.9
            results.append((move, score))
    
    # If castling available but blocked, suggest clearing moves
    if board.has_castling_rights(turn) and not results:
        # Find pieces blocking castling
        king_sq = board.king(turn)
        if king_sq:
            # Kingside blocking squares
            if board.has_kingside_castling_rights(turn):
                ks_blockers = [chess.F1, chess.G1] if turn == chess.WHITE else [chess.F8, chess.G8]
                for blocker_sq in ks_blockers:
                    piece = board.piece_at(blocker_sq)
                    if piece and piece.color == turn:
                        # Find moves for this blocking piece
                        for move in board.legal_moves:
                            if move.from_square == blocker_sq:
                                results.append((move, 0.7))  # Prep move
            
            # Queenside blocking squares
            if board.has_queenside_castling_rights(turn):
                qs_blockers = [chess.B1, chess.C1, chess.D1] if turn == chess.WHITE else [chess.B8, chess.C8, chess.D8]
                for blocker_sq in qs_blockers:
                    piece = board.piece_at(blocker_sq)
                    if piece and piece.color == turn:
                        for move in board.legal_moves:
                            if move.from_square == blocker_sq:
                                results.append((move, 0.6))
    
    return results


def get_center_control_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that control or occupy central squares.
    
    Returns list of (move, score) tuples.
    """
    results = []
    
    for move in board.legal_moves:
        score = 0.0
        
        # Moving to center square
        if move.to_square in CENTER_SQUARES:
            score = 1.0
        elif move.to_square in EXTENDED_CENTER:
            score = 0.7
        
        # Pawn moves to center
        piece = board.piece_at(move.from_square)
        if piece and piece.piece_type == chess.PAWN:
            if move.to_square in CENTER_SQUARES:
                score = 0.95  # Central pawns are key
        
        # Piece attacks on center
        if score == 0:
            board.push(move)
            attacks_center = 0
            new_attacks = board.attacks(move.to_square)
            for center_sq in CENTER_SQUARES:
                if center_sq in new_attacks:
                    attacks_center += 1
            board.pop()
            
            if attacks_center >= 2:
                score = 0.6
            elif attacks_center == 1:
                score = 0.4
        
        if score > 0:
            results.append((move, score))
    
    return results


def get_attack_king_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that attack squares around enemy king.
    
    Returns list of (move, score) tuples.
    """
    results = []
    enemy = not board.turn
    enemy_king = board.king(enemy)
    
    if enemy_king is None:
        return []
    
    # Get king zone (king + adjacent squares)
    king_zone = {enemy_king}
    for sq in chess.SQUARES:
        if chess.square_distance(enemy_king, sq) == 1:
            king_zone.add(sq)
    
    for move in board.legal_moves:
        board.push(move)
        
        # Count attacks on king zone after move
        attacks_on_zone = 0
        for sq in king_zone:
            if board.is_attacked_by(board.turn, sq):  # Note: turn flipped after push
                continue  # This is enemy attacking (wrong)
            if board.is_attacked_by(not board.turn, sq):
                attacks_on_zone += 1
        
        board.pop()
        
        if attacks_on_zone >= 3:
            score = 1.0
        elif attacks_on_zone >= 2:
            score = 0.8
        elif attacks_on_zone >= 1:
            score = 0.5
        else:
            score = 0.0
        
        # Bonus for checks
        if score > 0:
            board.push(move)
            if board.is_check():
                score = min(1.0, score + 0.2)
            board.pop()
        
        if score > 0:
            results.append((move, score))
    
    return results


def get_simplify_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that trade pieces (for when ahead in material).
    
    Returns list of (move, score) tuples.
    """
    results = []
    
    for move in board.legal_moves:
        if board.is_capture(move):
            captured = board.piece_at(move.to_square)
            capturer = board.piece_at(move.from_square)
            
            if captured and capturer:
                # Prefer equal or favorable trades
                cap_val = _piece_value(captured.piece_type)
                our_val = _piece_value(capturer.piece_type)
                
                if cap_val >= our_val:
                    # Good trade
                    score = 0.8 + (cap_val - our_val) * 0.02
                else:
                    # Only consider if recapture possible
                    board.push(move)
                    can_recapture = any(
                        board.is_capture(m) and m.to_square == move.to_square
                        for m in board.legal_moves
                    )
                    board.pop()
                    
                    if can_recapture:
                        score = 0.6
                    else:
                        score = 0.0
                
                if score > 0:
                    results.append((move, min(1.0, score)))
    
    return results


def get_pawn_advance_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get pawn moves that advance toward promotion.
    
    Returns list of (move, score) tuples.
    """
    results = []
    turn = board.turn
    promo_rank = 7 if turn == chess.WHITE else 0
    
    for move in board.legal_moves:
        piece = board.piece_at(move.from_square)
        if not piece or piece.piece_type != chess.PAWN:
            continue
        
        # Check if this is a passed pawn
        is_passed = _is_passed_pawn(board, move.from_square)
        to_rank = chess.square_rank(move.to_square)
        
        # Distance to promotion
        dist_to_promo = abs(promo_rank - to_rank)
        
        if move.promotion:
            score = 1.0  # Promotion!
        elif is_passed:
            score = 0.9 - (dist_to_promo * 0.1)
        else:
            score = 0.4 - (dist_to_promo * 0.05)
        
        if score > 0:
            results.append((move, score))
    
    return results


def get_king_activation_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that bring king toward center (endgame).
    
    Returns list of (move, score) tuples.
    """
    results = []
    king_sq = board.king(board.turn)
    
    if king_sq is None:
        return []
    
    # Center of board
    center_file = 3.5
    center_rank = 3.5
    
    for move in board.legal_moves:
        piece = board.piece_at(move.from_square)
        if not piece or piece.piece_type != chess.KING:
            continue
        
        # Calculate distance to center
        from_dist = abs(chess.square_file(move.from_square) - center_file) + \
                   abs(chess.square_rank(move.from_square) - center_rank)
        to_dist = abs(chess.square_file(move.to_square) - center_file) + \
                 abs(chess.square_rank(move.to_square) - center_rank)
        
        if to_dist < from_dist:
            # Moving toward center
            improvement = from_dist - to_dist
            score = min(1.0, 0.5 + improvement * 0.2)
            results.append((move, score))
    
    return results


def get_capture_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get captures that win material.
    
    Returns list of (move, score) tuples.
    """
    results = []
    
    for move in board.legal_moves:
        if not board.is_capture(move):
            continue
        
        captured = board.piece_at(move.to_square)
        capturer = board.piece_at(move.from_square)
        
        if not captured or not capturer:
            continue
        
        cap_val = _piece_value(captured.piece_type)
        our_val = _piece_value(capturer.piece_type)
        
        # Check if capture is defended
        board.push(move)
        is_defended = board.is_attacked_by(board.turn, move.to_square)
        board.pop()
        
        if is_defended:
            # Trade - only good if we win material
            net = cap_val - our_val
            if net > 0:
                score = 0.7 + net * 0.03
            else:
                score = 0.3  # Even trade
        else:
            # Free capture
            score = 0.9 + cap_val * 0.01
        
        results.append((move, min(1.0, score)))
    
    return results


def get_defensive_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that defend attacked pieces.
    
    Returns list of (move, score) tuples.
    """
    results = []
    turn = board.turn
    enemy = not turn
    
    # Find our attacked pieces
    attacked = []
    for sq in chess.SQUARES:
        piece = board.piece_at(sq)
        if piece and piece.color == turn:
            if board.is_attacked_by(enemy, sq):
                # Check if adequately defended
                attackers = len(list(board.attackers(enemy, sq)))
                defenders = len(list(board.attackers(turn, sq)))
                if attackers > defenders:
                    attacked.append((sq, piece, _piece_value(piece.piece_type)))
    
    if not attacked:
        return []
    
    # Sort by value (most valuable first)
    attacked.sort(key=lambda x: x[2], reverse=True)
    
    for sq, piece, value in attacked:
        # Find moves that defend this piece
        for move in board.legal_moves:
            board.push(move)
            
            # Check if piece is now defended
            new_defenders = len(list(board.attackers(turn, sq)))
            
            board.pop()
            
            if new_defenders > 0:
                score = 0.6 + value * 0.04
                results.append((move, min(1.0, score)))
        
        # Find moves that move the piece
        for move in board.legal_moves:
            if move.from_square == sq:
                # Moving the attacked piece
                board.push(move)
                still_attacked = board.is_attacked_by(enemy, move.to_square)
                board.pop()
                
                if not still_attacked:
                    score = 0.8 + value * 0.02
                    results.append((move, min(1.0, score)))
    
    return results


def get_weakness_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that create weaknesses in enemy position.
    
    Returns list of (move, score) tuples.
    """
    # Simplified: look for pawn moves that attack enemy pawns
    results = []
    turn = board.turn
    enemy = not turn
    
    for move in board.legal_moves:
        piece = board.piece_at(move.from_square)
        if not piece:
            continue
        
        # Pawn attacks on enemy pawns (creates doubled/isolated)
        if piece.piece_type == chess.PAWN:
            board.push(move)
            attacks = board.attacks(move.to_square)
            attacks_pawn = False
            for sq in attacks:
                target = board.piece_at(sq)
                if target and target.color == enemy and target.piece_type == chess.PAWN:
                    attacks_pawn = True
                    break
            board.pop()
            
            if attacks_pawn:
                results.append((move, 0.6))
    
    return results


def get_improvement_moves(board: chess.Board) -> List[Tuple[chess.Move, float]]:
    """
    Get moves that improve piece positioning.
    
    Returns list of (move, score) tuples.
    """
    results = []
    
    for move in board.legal_moves:
        piece = board.piece_at(move.from_square)
        if not piece:
            continue
        
        # Count attacks before and after
        board.push(move)
        new_attacks = len(list(board.attacks(move.to_square)))
        board.pop()
        
        old_attacks = len(list(board.attacks(move.from_square)))
        
        improvement = new_attacks - old_attacks
        if improvement > 0:
            score = 0.5 + improvement * 0.1
            results.append((move, min(1.0, score)))
    
    return results


def select_weighted_move(
    candidates: List[PlanMoveCandidate],
    temperature: float = 1.0,
) -> Optional[chess.Move]:
    """
    Select a move from candidates based on weighted scores.
    
    Args:
        candidates: List of PlanMoveCandidate objects
        temperature: Randomness factor (0=deterministic, >1=more random)
        
    Returns:
        Selected move or None if no candidates
    """
    if not candidates:
        return None
    
    # Sort by final score
    sorted_candidates = sorted(candidates, key=lambda c: c.final_score, reverse=True)
    
    if temperature == 0:
        return sorted_candidates[0].move
    
    # Sample with temperature
    scores = [c.final_score ** (1 / temperature) for c in sorted_candidates]
    total = sum(scores)
    
    if total == 0:
        return random.choice(sorted_candidates).move
    
    probs = [s / total for s in scores]
    r = random.random()
    cumulative = 0
    
    for candidate, prob in zip(sorted_candidates, probs):
        cumulative += prob
        if r <= cumulative:
            return candidate.move
    
    return sorted_candidates[0].move


# Helper functions

def _piece_value(piece_type: chess.PieceType) -> int:
    """Get standard piece value."""
    values = {
        chess.PAWN: 1,
        chess.KNIGHT: 3,
        chess.BISHOP: 3,
        chess.ROOK: 5,
        chess.QUEEN: 9,
        chess.KING: 0,
    }
    return values.get(piece_type, 0)


def _is_passed_pawn(board: chess.Board, pawn_sq: chess.Square) -> bool:
    """Check if a pawn is passed (no enemy pawns blocking)."""
    piece = board.piece_at(pawn_sq)
    if not piece or piece.piece_type != chess.PAWN:
        return False
    
    color = piece.color
    enemy = not color
    pawn_file = chess.square_file(pawn_sq)
    pawn_rank = chess.square_rank(pawn_sq)
    
    # Check files: same file and adjacent files
    for file_offset in [-1, 0, 1]:
        check_file = pawn_file + file_offset
        if not (0 <= check_file <= 7):
            continue
        
        # Check ranks ahead of the pawn
        if color == chess.WHITE:
            rank_range = range(pawn_rank + 1, 8)
        else:
            rank_range = range(pawn_rank - 1, -1, -1)
        
        for rank in rank_range:
            sq = chess.square(check_file, rank)
            blocker = board.piece_at(sq)
            if blocker and blocker.color == enemy and blocker.piece_type == chess.PAWN:
                return False
    
    return True

