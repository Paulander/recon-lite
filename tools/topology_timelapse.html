<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Topology Timelapse</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Controls panel */
        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 16px;
            min-width: 260px;
            z-index: 100;
        }

        h1 {
            font-size: 1rem;
            margin-bottom: 12px;
            color: #58a6ff;
        }

        .control-row {
            margin-bottom: 12px;
        }

        .control-row label {
            display: block;
            font-size: 0.7rem;
            color: #8b949e;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        input[type="file"] {
            display: none;
        }

        .file-label {
            display: inline-block;
            padding: 8px 16px;
            background: linear-gradient(135deg, #238636, #2ea043);
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            color: #fff;
            transition: transform 0.2s;
        }

        .file-label:hover {
            transform: translateY(-1px);
        }

        .playback-btns {
            display: flex;
            gap: 6px;
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            background: #21262d;
            color: #c9d1d9;
            cursor: pointer;
            font-size: 0.8rem;
            border: 1px solid #30363d;
        }

        .btn:hover {
            background: #30363d;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .btn.active {
            background: #238636;
            border-color: #2ea043;
        }

        input[type="range"] {
            width: 100%;
            accent-color: #58a6ff;
        }

        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            color: #8b949e;
        }

        /* Stats panel */
        #stats {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 12px;
            padding: 16px;
            min-width: 160px;
            z-index: 100;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            padding: 3px 0;
        }

        .stat-value {
            color: #58a6ff;
            font-weight: 600;
        }

        .stat-add {
            color: #3fb950;
        }

        .stat-remove {
            color: #f85149;
        }

        /* Stage banner */
        #stage-banner {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 27, 34, 0.9);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 10px 24px;
            text-align: center;
            z-index: 100;
        }

        #stage-text {
            font-size: 1.1rem;
            font-weight: 600;
            color: #58a6ff;
        }

        /* Progress bar */
        #progress-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: #21262d;
        }

        #progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #238636, #58a6ff);
            width: 0%;
            transition: width 0.1s;
        }

        /* Timeline */
        #timeline {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px 20px;
            min-width: 400px;
            text-align: center;
            z-index: 100;
        }

        #timeline-label {
            font-size: 0.85rem;
            margin-bottom: 6px;
            color: #c9d1d9;
        }

        #timeline-slider {
            width: 100%;
        }

        /* Legend */
        #legend {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px;
            font-size: 0.7rem;
            z-index: 100;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            margin: 3px 0;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        /* Depth legend */
        #depth-legend {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(22, 27, 34, 0.95);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 12px;
            font-size: 0.7rem;
            z-index: 100;
        }

        .depth-bar {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .depth-gradient {
            width: 100px;
            height: 12px;
            background: linear-gradient(90deg, #58a6ff, #a371f7, #f778ba);
            border-radius: 2px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="canvas-wrapper">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <!-- Controls -->
    <div id="controls">
        <h1>üé¨ Topology Timelapse</h1>
        <div class="control-row">
            <label>Load Run Folder</label>
            <label class="file-label" for="file-input">üìÇ Select Folder</label>
            <input type="file" id="file-input" webkitdirectory multiple>
        </div>
        <div class="control-row">
            <label>Playback</label>
            <div class="playback-btns">
                <button class="btn" id="prev-btn" disabled>‚óÄ</button>
                <button class="btn" id="play-btn" disabled>‚ñ∂ Play</button>
                <button class="btn" id="next-btn" disabled>‚ñ∂</button>
            </div>
        </div>
        <div class="control-row">
            <label>Speed: <span id="speed-label">100ms</span></label>
            <input type="range" id="speed-slider" min="30" max="500" value="100">
        </div>
        <div class="control-row checkbox-row">
            <input type="checkbox" id="show-edges" checked>
            <span>Show edges</span>
        </div>
        <div class="control-row checkbox-row">
            <input type="checkbox" id="depth-color" checked>
            <span>Color by depth</span>
        </div>
        <div class="control-row checkbox-row">
            <input type="checkbox" id="loop-playback">
            <span>Loop playback</span>
        </div>
    </div>

    <!-- Stats -->
    <div id="stats">
        <div class="stat-row"><span>Stage</span><span class="stat-value" id="stat-stage">-</span></div>
        <div class="stat-row"><span>Cycle</span><span class="stat-value" id="stat-cycle">-</span></div>
        <div class="stat-row"><span>Nodes</span><span class="stat-value" id="stat-nodes">0</span></div>
        <div class="stat-row"><span>Edges</span><span class="stat-value" id="stat-edges">0</span></div>
        <div class="stat-row"><span>Added</span><span class="stat-value stat-add" id="stat-added">0</span></div>
        <div class="stat-row"><span>Removed</span><span class="stat-value stat-remove" id="stat-removed">0</span></div>
    </div>

    <!-- Stage Banner -->
    <div id="stage-banner">
        <div id="stage-text">Load a run folder</div>
    </div>

    <!-- Timeline -->
    <div id="timeline">
        <div id="timeline-label">Frame 0 / 0</div>
        <input type="range" id="timeline-slider" min="0" max="0" value="0" disabled>
    </div>

    <!-- Legend -->
    <div id="legend">
        <div class="legend-item">
            <div class="legend-dot" style="background:#3fb950"></div><span>Added</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background:#f85149"></div><span>Removed</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background:#58a6ff"></div><span>Backbone</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot" style="background:#a371f7"></div><span>Stem/Trial</span>
        </div>
    </div>

    <!-- Depth Legend -->
    <div id="depth-legend">
        <div class="depth-bar">
            <span>Shallow</span>
            <div class="depth-gradient"></div>
            <span>Deep</span>
        </div>
    </div>

    <!-- Progress Bar -->
    <div id="progress-bar">
        <div id="progress-fill"></div>
    </div>

    <script>
        // ============ Configuration ============
        const CONFIG = {
            nodeBaseRadius: 4,
            nodeMaxRadius: 12,
            edgeAlpha: 0.3,
            flashDuration: 300,  // ms for add/remove flash
            layoutIterations: 100,
            layoutK: 0.5,         // Force constant
            colors: {
                bg: '#0d1117',
                node: '#58a6ff',
                nodeDeep: '#f778ba',
                nodeMid: '#a371f7',
                edge: '#30363d',
                added: '#3fb950',
                removed: '#f85149',
                sensor: '#79c0ff',
                actuator: '#ffa657',
                stemCell: '#a371f7',
                trial: '#d2a8ff',
            }
        };

        // ============ State ============
        let canvas, ctx;
        let allFrames = [];  // Flattened: [{stage, cycle, data, prevData}]
        let currentFrameIdx = 0;
        let isPlaying = false;
        let playInterval = null;
        let nodePositions = {};  // Stable positions: nodeId -> {x, y}
        let flashNodes = {};     // nodeId -> {color, startTime}
        let flashEdges = {};     // edgeKey -> {color, startTime}
        let lastRenderTime = 0;

        // ============ Initialization ============
        function init() {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Event listeners
            document.getElementById('file-input').addEventListener('change', handleFileInput);
            document.getElementById('play-btn').addEventListener('click', togglePlay);
            document.getElementById('prev-btn').addEventListener('click', prevFrame);
            document.getElementById('next-btn').addEventListener('click', nextFrame);
            document.getElementById('timeline-slider').addEventListener('input', e => goToFrame(+e.target.value));
            document.getElementById('speed-slider').addEventListener('input', e => {
                document.getElementById('speed-label').textContent = e.target.value + 'ms';
                if (isPlaying) {
                    stopPlay();
                    startPlay();
                }
            });

            // Initial render
            render();
        }

        function resizeCanvas() {
            const wrapper = document.getElementById('canvas-wrapper');
            canvas.width = wrapper.clientWidth * window.devicePixelRatio;
            canvas.height = wrapper.clientHeight * window.devicePixelRatio;
            canvas.style.width = wrapper.clientWidth + 'px';
            canvas.style.height = wrapper.clientHeight + 'px';
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            render();
        }

        // ============ File Loading ============
        async function handleFileInput(e) {
            const files = Array.from(e.target.files).filter(f => f.name.endsWith('.json') && f.name.startsWith('cycle_'));
            if (files.length === 0) {
                alert('No cycle_*.json files found!');
                return;
            }

            // Group by stage folder
            const stageMap = new Map();
            for (const f of files) {
                const pathParts = f.webkitRelativePath.split('/');
                const stageName = pathParts[pathParts.length - 2] || 'root';
                if (!stageMap.has(stageName)) {
                    stageMap.set(stageName, []);
                }
                const data = JSON.parse(await f.text());
                stageMap.get(stageName).push({ name: f.name, data });
            }

            // Sort stages and files, build flat frame list
            const sortedStages = Array.from(stageMap.entries())
                .sort((a, b) => a[0].localeCompare(b[0], undefined, { numeric: true }));

            allFrames = [];
            for (const [stageName, stageFiles] of sortedStages) {
                stageFiles.sort((a, b) => a.name.localeCompare(b.name));
                for (let i = 0; i < stageFiles.length; i++) {
                    allFrames.push({
                        stage: stageName,
                        cycle: i + 1,
                        data: stageFiles[i].data,
                        prevData: i > 0 ? stageFiles[i - 1].data : (allFrames.length > 0 ? allFrames[allFrames.length - 1].data : null)
                    });
                }
            }

            console.log(`Loaded ${allFrames.length} frames from ${sortedStages.length} stages`);

            // Initialize layout from first frame
            if (allFrames.length > 0) {
                initLayout(allFrames[0].data);
            }

            // Enable controls
            document.getElementById('play-btn').disabled = false;
            document.getElementById('prev-btn').disabled = false;
            document.getElementById('next-btn').disabled = false;
            document.getElementById('timeline-slider').disabled = false;
            document.getElementById('timeline-slider').max = allFrames.length - 1;

            currentFrameIdx = 0;
            goToFrame(0);
        }

        // ============ Layout ============
        function initLayout(snapshot) {
            const nodes = snapshot.nodes || {};
            const edges = snapshot.edges || {};

            // Build adjacency for hierarchy detection
            const childrenOf = {};
            const parentOf = {};

            Object.values(edges).forEach(e => {
                const etype = (e.type || e.ltype || '').toLowerCase();
                if (etype === 'sub') {
                    if (!childrenOf[e.src]) childrenOf[e.src] = [];
                    // Avoid duplicate children (some nodes have multiple parents)
                    if (!childrenOf[e.src].includes(e.dst)) {
                        childrenOf[e.src].push(e.dst);
                    }
                    // Only track first parent for tree layout
                    if (!parentOf[e.dst]) {
                        parentOf[e.dst] = e.src;
                    }
                }
            });

            // Find roots
            const nodeIds = Object.keys(nodes);
            const roots = nodeIds.filter(id => !parentOf[id]);

            // Calculate subtree sizes for proportional spacing
            const subtreeSize = {};
            function calcSubtreeSize(nodeId) {
                if (subtreeSize[nodeId] !== undefined) return subtreeSize[nodeId];
                const kids = childrenOf[nodeId] || [];
                if (kids.length === 0) {
                    subtreeSize[nodeId] = 1;
                } else {
                    subtreeSize[nodeId] = kids.reduce((sum, kid) => sum + calcSubtreeSize(kid), 0);
                }
                return subtreeSize[nodeId];
            }
            nodeIds.forEach(n => calcSubtreeSize(n));

            // Assign depths via BFS from roots
            const depths = {};
            const queue = [...roots];
            roots.forEach(r => depths[r] = 0);
            while (queue.length > 0) {
                const curr = queue.shift();
                const kids = childrenOf[curr] || [];
                kids.forEach(kid => {
                    if (depths[kid] === undefined) {
                        depths[kid] = depths[curr] + 1;
                        queue.push(kid);
                    }
                });
            }
            // Orphan nodes
            nodeIds.forEach(id => {
                if (depths[id] === undefined) depths[id] = 0;
            });

            const maxDepth = Math.max(...Object.values(depths), 0);
            const W = canvas.width / window.devicePixelRatio;
            const H = canvas.height / window.devicePixelRatio;
            const margin = 60;

            nodePositions = {};

            // Tree layout: position recursively with proportional spacing
            function layoutTree(nodeId, xMin, xMax, depth) {
                const y = margin + ((H - 2 * margin) * depth / Math.max(maxDepth, 1));
                const x = (xMin + xMax) / 2;
                nodePositions[nodeId] = {
                    x: x,
                    y: y,
                    depth: depth,
                    maxDepth: maxDepth
                };

                const kids = childrenOf[nodeId] || [];
                if (kids.length === 0) return;

                // Distribute children proportionally based on subtree size
                const totalSubtree = kids.reduce((sum, k) => sum + subtreeSize[k], 0);
                let currentX = xMin;

                kids.forEach(kid => {
                    const kidWidth = ((xMax - xMin) * subtreeSize[kid]) / totalSubtree;
                    layoutTree(kid, currentX, currentX + kidWidth, depth + 1);
                    currentX += kidWidth;
                });
            }

            // Layout each root tree
            const totalRootSize = roots.reduce((sum, r) => sum + subtreeSize[r], 0) || 1;
            let currentX = margin;
            const availableWidth = W - 2 * margin;

            roots.forEach(root => {
                const rootWidth = (availableWidth * subtreeSize[root]) / totalRootSize;
                layoutTree(root, currentX, currentX + rootWidth, 0);
                currentX += rootWidth;
            });

            // Position any orphan nodes
            const orphans = nodeIds.filter(id => !nodePositions[id]);
            orphans.forEach((id, i) => {
                nodePositions[id] = {
                    x: margin + (i + 1) * 30,
                    y: H - margin,
                    depth: maxDepth,
                    maxDepth: maxDepth
                };
            });

            // Light force to prevent overlap while keeping tree structure
            forceLayoutLight(nodes, edges, 20);
        }

        // Lighter force layout that preserves Y hierarchy
        function forceLayoutLight(nodes, edges, iterations = 20) {
            const nodeIds = Object.keys(nodes);
            const W = canvas.width / window.devicePixelRatio;
            const margin = 60;

            for (let iter = 0; iter < iterations; iter++) {
                // Only X repulsion between nodes at same depth
                const byY = {};
                nodeIds.forEach(id => {
                    const y = Math.round(nodePositions[id]?.y || 0);
                    if (!byY[y]) byY[y] = [];
                    byY[y].push(id);
                });

                Object.values(byY).forEach(sameDepthNodes => {
                    for (let i = 0; i < sameDepthNodes.length; i++) {
                        for (let j = i + 1; j < sameDepthNodes.length; j++) {
                            const u = sameDepthNodes[i], v = sameDepthNodes[j];
                            if (!nodePositions[u] || !nodePositions[v]) continue;
                            const dx = nodePositions[u].x - nodePositions[v].x;
                            const dist = Math.abs(dx) || 0.1;
                            const minDist = 25; // Minimum distance between nodes
                            if (dist < minDist) {
                                const push = (minDist - dist) / 2;
                                const dir = dx > 0 ? 1 : -1;
                                nodePositions[u].x += dir * push * 0.5;
                                nodePositions[v].x -= dir * push * 0.5;
                            }
                        }
                    }
                });

                // Clamp to bounds
                nodeIds.forEach(id => {
                    if (nodePositions[id]) {
                        nodePositions[id].x = Math.max(margin, Math.min(W - margin, nodePositions[id].x));
                    }
                });
            }
        }

        function forceLayout(nodes, edges, iterations = 50) {
            const nodeIds = Object.keys(nodes);
            const W = canvas.width / window.devicePixelRatio;
            const H = canvas.height / window.devicePixelRatio;
            const margin = 60;

            // Ensure all nodes have positions
            nodeIds.forEach(id => {
                if (!nodePositions[id]) {
                    nodePositions[id] = {
                        x: margin + Math.random() * (W - 2 * margin),
                        y: margin + Math.random() * (H - 2 * margin),
                        depth: 0,
                        maxDepth: 1
                    };
                }
            });

            const k = Math.sqrt((W * H) / nodeIds.length) * CONFIG.layoutK;
            const temp = W / 10;

            for (let iter = 0; iter < iterations; iter++) {
                const disp = {};
                nodeIds.forEach(id => disp[id] = { x: 0, y: 0 });

                // Repulsion between all nodes
                for (let i = 0; i < nodeIds.length; i++) {
                    for (let j = i + 1; j < nodeIds.length; j++) {
                        const u = nodeIds[i], v = nodeIds[j];
                        const dx = nodePositions[u].x - nodePositions[v].x;
                        const dy = nodePositions[u].y - nodePositions[v].y;
                        const dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
                        const force = (k * k) / dist;
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        disp[u].x += fx;
                        disp[u].y += fy;
                        disp[v].x -= fx;
                        disp[v].y -= fy;
                    }
                }

                // Attraction along edges
                Object.values(edges).forEach(e => {
                    const u = e.src, v = e.dst;
                    if (!nodePositions[u] || !nodePositions[v]) return;
                    const dx = nodePositions[u].x - nodePositions[v].x;
                    const dy = nodePositions[u].y - nodePositions[v].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
                    const force = (dist * dist) / k;
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    disp[u].x -= fx * 0.5;
                    disp[u].y -= fy * 0.5;
                    disp[v].x += fx * 0.5;
                    disp[v].y += fy * 0.5;
                });

                // Apply with cooling
                const cooling = 1 - iter / iterations;
                nodeIds.forEach(id => {
                    const d = disp[id];
                    const dist = Math.sqrt(d.x * d.x + d.y * d.y) || 0.01;
                    const maxMove = temp * cooling;
                    const move = Math.min(dist, maxMove);
                    nodePositions[id].x += (d.x / dist) * move;
                    nodePositions[id].y += (d.y / dist) * move;
                    // Clamp to bounds
                    nodePositions[id].x = Math.max(margin, Math.min(W - margin, nodePositions[id].x));
                    nodePositions[id].y = Math.max(margin, Math.min(H - margin, nodePositions[id].y));
                });
            }
        }

        function updateLayout(snapshot) {
            const nodes = snapshot.nodes || {};
            const edges = snapshot.edges || {};
            const nodeIds = Object.keys(nodes);

            // Find new nodes and position near their parent
            nodeIds.forEach(id => {
                if (!nodePositions[id]) {
                    // Find parent via SUB edge
                    let parentId = null;
                    Object.values(edges).forEach(e => {
                        const etype = (e.type || e.ltype || '').toLowerCase();
                        if (etype === 'sub' && e.dst === id && nodePositions[e.src]) {
                            parentId = e.src;
                        }
                    });

                    const W = canvas.width / window.devicePixelRatio;
                    const H = canvas.height / window.devicePixelRatio;

                    if (parentId && nodePositions[parentId]) {
                        const parent = nodePositions[parentId];
                        nodePositions[id] = {
                            x: parent.x + (Math.random() - 0.5) * 60,
                            y: parent.y + 40 + Math.random() * 20,
                            depth: (parent.depth || 0) + 1,
                            maxDepth: parent.maxDepth || 1
                        };
                    } else {
                        nodePositions[id] = {
                            x: 100 + Math.random() * (W - 200),
                            y: 100 + Math.random() * (H - 200),
                            depth: 0,
                            maxDepth: 1
                        };
                    }
                }
            });

            // Light force iteration to settle new nodes
            forceLayout(nodes, edges, 10);
        }

        // ============ Rendering ============
        function render() {
            const now = Date.now();
            const W = canvas.width / window.devicePixelRatio;
            const H = canvas.height / window.devicePixelRatio;

            ctx.fillStyle = CONFIG.colors.bg;
            ctx.fillRect(0, 0, W, H);

            if (allFrames.length === 0) {
                ctx.fillStyle = '#8b949e';
                ctx.font = '16px system-ui';
                ctx.textAlign = 'center';
                ctx.fillText('Load a folder with cycle_*.json snapshots', W / 2, H / 2);
                return;
            }

            const frame = allFrames[currentFrameIdx];
            const nodes = frame.data.nodes || {};
            const edges = frame.data.edges || {};
            const showEdges = document.getElementById('show-edges').checked;
            const depthColor = document.getElementById('depth-color').checked;

            // Draw edges
            if (showEdges) {
                Object.entries(edges).forEach(([key, e]) => {
                    const src = nodePositions[e.src];
                    const dst = nodePositions[e.dst];
                    if (!src || !dst) return;

                    let color = CONFIG.colors.edge;
                    let alpha = CONFIG.edgeAlpha;

                    // Check flash
                    if (flashEdges[key]) {
                        const elapsed = now - flashEdges[key].startTime;
                        if (elapsed < CONFIG.flashDuration) {
                            color = flashEdges[key].color;
                            alpha = 0.8 * (1 - elapsed / CONFIG.flashDuration);
                        } else {
                            delete flashEdges[key];
                        }
                    }

                    ctx.beginPath();
                    ctx.moveTo(src.x, src.y);
                    ctx.lineTo(dst.x, dst.y);
                    ctx.strokeStyle = color;
                    ctx.globalAlpha = alpha;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                });
            }

            // Draw nodes
            Object.entries(nodes).forEach(([id, node]) => {
                const pos = nodePositions[id];
                if (!pos) return;

                const group = node.group || '';
                let baseColor = CONFIG.colors.node;

                // Color by depth if enabled
                if (depthColor && pos.maxDepth > 0) {
                    const t = pos.depth / pos.maxDepth;
                    baseColor = lerpColor(CONFIG.colors.node, CONFIG.colors.nodeDeep, t);
                }

                // Group-based coloring
                if (group === 'sensor') baseColor = CONFIG.colors.sensor;
                else if (group === 'actuator') baseColor = CONFIG.colors.actuator;
                else if (group === 'stem_cell') baseColor = CONFIG.colors.stemCell;
                else if (group === 'trial') baseColor = CONFIG.colors.trial;

                let color = baseColor;
                let radius = CONFIG.nodeBaseRadius;
                let glowRadius = 0;

                // Check flash state
                if (flashNodes[id]) {
                    const elapsed = now - flashNodes[id].startTime;
                    if (elapsed < CONFIG.flashDuration) {
                        const progress = elapsed / CONFIG.flashDuration;
                        color = flashNodes[id].color;
                        glowRadius = 12 * (1 - progress);
                        radius = CONFIG.nodeBaseRadius + 4 * (1 - progress);
                    } else {
                        delete flashNodes[id];
                    }
                }

                // Draw glow
                if (glowRadius > 0) {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, radius + glowRadius, 0, Math.PI * 2);
                    ctx.fillStyle = color;
                    ctx.globalAlpha = 0.3;
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }

                // Draw node
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            });

            // Schedule next frame if flashing
            if (Object.keys(flashNodes).length > 0 || Object.keys(flashEdges).length > 0) {
                requestAnimationFrame(render);
            }
        }

        function lerpColor(c1, c2, t) {
            // Simple hex lerp
            const r1 = parseInt(c1.slice(1, 3), 16);
            const g1 = parseInt(c1.slice(3, 5), 16);
            const b1 = parseInt(c1.slice(5, 7), 16);
            const r2 = parseInt(c2.slice(1, 3), 16);
            const g2 = parseInt(c2.slice(3, 5), 16);
            const b2 = parseInt(c2.slice(5, 7), 16);
            const r = Math.round(r1 + (r2 - r1) * t);
            const g = Math.round(g1 + (g2 - g1) * t);
            const b = Math.round(b1 + (b2 - b1) * t);
            return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
        }

        // ============ Navigation ============
        function goToFrame(idx) {
            if (idx < 0 || idx >= allFrames.length) return;

            const prevIdx = currentFrameIdx;
            currentFrameIdx = idx;
            const frame = allFrames[idx];

            // Update layout for new nodes
            updateLayout(frame.data);

            // Compute diff and trigger flashes
            const prevNodes = frame.prevData?.nodes || {};
            const currNodes = frame.data.nodes || {};
            const prevEdges = frame.prevData?.edges || {};
            const currEdges = frame.data.edges || {};

            const addedNodes = Object.keys(currNodes).filter(id => !prevNodes[id]);
            const removedNodes = Object.keys(prevNodes).filter(id => !currNodes[id]);
            const addedEdges = Object.keys(currEdges).filter(k => !prevEdges[k]);
            const removedEdges = Object.keys(prevEdges).filter(k => !currEdges[k]);

            const now = Date.now();
            addedNodes.forEach(id => flashNodes[id] = { color: CONFIG.colors.added, startTime: now });
            removedNodes.forEach(id => flashNodes[id] = { color: CONFIG.colors.removed, startTime: now });
            addedEdges.forEach(k => flashEdges[k] = { color: CONFIG.colors.added, startTime: now });
            removedEdges.forEach(k => flashEdges[k] = { color: CONFIG.colors.removed, startTime: now });

            // Update UI
            document.getElementById('stat-stage').textContent = frame.stage;
            document.getElementById('stat-cycle').textContent = frame.cycle;
            document.getElementById('stat-nodes').textContent = Object.keys(currNodes).length;
            document.getElementById('stat-edges').textContent = Object.keys(currEdges).length;
            document.getElementById('stat-added').textContent = addedNodes.length;
            document.getElementById('stat-removed').textContent = removedNodes.length;
            document.getElementById('stage-text').textContent = `${frame.stage} ‚Ä¢ Cycle ${frame.cycle}`;
            document.getElementById('timeline-label').textContent = `Frame ${idx + 1} / ${allFrames.length}`;
            document.getElementById('timeline-slider').value = idx;
            document.getElementById('progress-fill').style.width = `${(idx + 1) / allFrames.length * 100}%`;

            render();
        }

        function nextFrame() {
            if (currentFrameIdx < allFrames.length - 1) {
                goToFrame(currentFrameIdx + 1);
            } else if (document.getElementById('loop-playback').checked) {
                goToFrame(0);
            } else {
                stopPlay();
            }
        }

        function prevFrame() {
            if (currentFrameIdx > 0) {
                goToFrame(currentFrameIdx - 1);
            }
        }

        function togglePlay() {
            if (isPlaying) {
                stopPlay();
            } else {
                startPlay();
            }
        }

        function startPlay() {
            isPlaying = true;
            document.getElementById('play-btn').textContent = '‚è∏ Pause';
            document.getElementById('play-btn').classList.add('active');
            const speed = +document.getElementById('speed-slider').value;
            playInterval = setInterval(nextFrame, speed);
        }

        function stopPlay() {
            isPlaying = false;
            document.getElementById('play-btn').textContent = '‚ñ∂ Play';
            document.getElementById('play-btn').classList.remove('active');
            if (playInterval) {
                clearInterval(playInterval);
                playInterval = null;
            }
        }

        // Start
        init();
    </script>
</body>

</html>