<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReCoN Game Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
    <script>
        const params = new URLSearchParams(window.location.search);
        window.__RECON_PROFILE__ = params.get('profile') || 'generic';
    </script>
</head>
<body>
    <div class="header">
        <h1><i class="fas fa-chess-rook"></i> ReCoN Game Visualization</h1>
        <div id="game-info" style="font-size: 0.8em; color: rgba(255,255,255,0.8); margin-top: 5px;">
            Loading visualization data...
        </div>
    </div>

    <div class="main-content">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Chess Board -->
            <div class="chess-container">
                <div class="chess-board" id="chess-board"></div>
                <div class="chess-info" id="chess-info">Loading position...</div>
            </div>

        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- ReCoN Network -->
            <div class="network-container">
                <div class="network-header">
                    <div class="network-title"><i class="fas fa-project-diagram"></i> ReCoN Network</div>
                    <div class="network-legend">
                        <div class="legend-row">
                            <span class="legend-label">Nodes:</span>
                            <span class="state-inactive">Inactive</span>
                            <span class="state-requested">Requested</span>
                            <span class="state-active">Active</span>
                            <span class="state-suppressed">Suppressed</span>
                            <span class="state-waiting">Waiting</span>
                            <span class="state-true">True</span>
                            <span class="state-confirmed">Confirmed</span>
                            <span class="state-failed">Failed</span>
                        </div>
                        <div class="legend-row">
                            <span class="legend-label">Edges:</span>
                            <span class="edge-sub">SUB</span>
                            <span class="edge-por">POR</span>
                            <span class="edge-ret">RET</span>
                            <span class="edge-sur">SUR</span>
                        </div>
                    </div>
                </div>
                <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap: wrap;">
                    <input type="file" id="file-input" accept="application/json" />
                    <button class="control-btn" id="load-file-btn">Load JSON</button>
                    <input type="file" id="topology-input" accept="application/json" />
                    <button class="control-btn" id="load-topology-btn">Load Topology</button>
                    <div style="display:flex; align-items:center; gap:6px;">
                        <span style="font-size:12px;color:#555;">Speed</span>
                        <select id="speed-select" class="control-btn" style="padding:6px 10px; background:#fff; color:#333; border:1px solid #ddd;">
                            <option value="1">1x</option>
                            <option value="2">2x</option>
                            <option value="4">4x</option>
                        </select>
                    </div>
                    <div style="font-size:12px;color:#555;">Shape: sensors = ◇, others = ●</div>
                    <label for="toggle-labels" class="label-toggle">
                        <input type="checkbox" id="toggle-labels" checked>
                        <span>Show labels</span>
                    </label>
                    <label for="toggle-active-only" class="label-toggle">
                        <input type="checkbox" id="toggle-active-only">
                        <span>Active only</span>
                    </label>
                    <label for="toggle-fade-edges" class="label-toggle">
                        <input type="checkbox" id="toggle-fade-edges">
                        <span>Fade inactive edges</span>
                    </label>
                    <label for="toggle-highlight-path" class="label-toggle">
                        <input type="checkbox" id="toggle-highlight-path" checked>
                        <span>Highlight active path</span>
                    </label>
                    <label for="toggle-path-only" class="label-toggle">
                        <input type="checkbox" id="toggle-path-only">
                        <span>Path only</span>
                    </label>
                    <label for="toggle-small-nodes" class="label-toggle">
                        <input type="checkbox" id="toggle-small-nodes">
                        <span>Small nodes</span>
                    </label>
                    <label for="toggle-changed-only" class="label-toggle">
                        <input type="checkbox" id="toggle-changed-only">
                        <span>Changed only</span>
                    </label>
                    <label for="layout-mode" class="label-toggle">
                        <span>Layout</span>
                        <select id="layout-mode" class="control-btn" style="padding:6px 10px; background:#fff; color:#333; border:1px solid #ddd;">
                            <option value="static">Static</option>
                            <option value="hier">Hierarchy</option>
                        </select>
                    </label>
                    <label for="toggle-bindings" class="label-toggle">
                        <input type="checkbox" id="toggle-bindings" checked>
                        <span>Show bindings</span>
                    </label>
                    <label for="toggle-compact" class="label-toggle">
                        <input type="checkbox" id="toggle-compact" checked>
                        <span>Collapse wrappers</span>
                    </label>
                </div>
                <canvas id="network-canvas" style="flex: 1; border-radius: 8px; background: #f8f9fa;"></canvas>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn" id="prev-btn" disabled>
            <i class="fas fa-step-backward"></i> Previous
        </button>
        <button class="control-btn" id="play-pause-btn">
            <i class="fas fa-play"></i> Play
        </button>
        <button class="control-btn" id="next-btn" disabled>
            Next <i class="fas fa-step-forward"></i>
        </button>
        <button class="control-btn" id="prev-move-btn" disabled>
            <i class="fas fa-backward"></i> Prev Move
        </button>
        <button class="control-btn" id="next-move-btn" disabled>
            Next Move <i class="fas fa-forward"></i>
        </button>
        <div class="jump-container">
            <label for="step-input">Step</label>
            <input id="step-input" class="jump-input" type="number" min="1" value="1">
            <button class="control-btn jump-btn" id="jump-btn">Go</button>
        </div>
        <div class="step-counter" id="step-counter">Step 0 / 0</div>
    </div>

    <script src="data-manager.js"></script>
    <script src="chess-board.js"></script>
    <script src="network-visualization.js"></script>
    <script>
        // Main application controller
        // Coordinates between the different visualization modules

        class ReConVisualization {
            constructor() {
                this.currentStep = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.speedFactor = 1;
                this.moveSteps = []; // indices where a move was applied/logged
                this.stepInput = null;
                this.jumpButton = null;

                // Initialize modules
                this.dataManager = new DataManager();
                this.chessBoard = new ChessBoard();
                this.networkVis = new NetworkVisualization();
            }

            async init() {
                console.log('Initializing ReCoN visualization...');

                try {
                    // Initialize chess board first (show placeholder)
                    this.chessBoard.init();

                    // Initialize network visualization
                    this.networkVis.init();

                    // Setup controls
                    this.setupControls();

                    // Load visualization data (this will show initial state)
                    await this.dataManager.loadVisualizationData();
                    await this.dataManager.loadTopology();

                    // Set external edges if available
                    const externalEdges = this.dataManager.getExternalEdges();
                    if (externalEdges) {
                        this.networkVis.setExternalEdges(externalEdges);
                    }

                    const topology = this.dataManager.getTopology();
                    if (topology) {
                        this.networkVis.setTemplateGraph(topology);
                    }

                    console.log('ReCoN visualization initialized successfully');

                } catch (error) {
                    console.error('Error initializing application:', error);
                    document.getElementById('game-info').textContent = 'Error initializing visualization';
                }
            }

            // Setup controls
            setupControls() {
                const prevBtn = document.getElementById('prev-btn');
                const nextBtn = document.getElementById('next-btn');
                const playPauseBtn = document.getElementById('play-pause-btn');
                const speedSelect = document.getElementById('speed-select');
                const prevMoveBtn = document.getElementById('prev-move-btn');
                const nextMoveBtn = document.getElementById('next-move-btn');
                const labelToggle = document.getElementById('toggle-labels');
                const bindingsToggle = document.getElementById('toggle-bindings');
                const activeOnlyToggle = document.getElementById('toggle-active-only');
                const fadeEdgesToggle = document.getElementById('toggle-fade-edges');
                const highlightPathToggle = document.getElementById('toggle-highlight-path');
                const pathOnlyToggle = document.getElementById('toggle-path-only');
                const smallNodesToggle = document.getElementById('toggle-small-nodes');
                const changedOnlyToggle = document.getElementById('toggle-changed-only');
                const layoutModeSelect = document.getElementById('layout-mode');
                const stepInput = document.getElementById('step-input');
                const jumpBtn = document.getElementById('jump-btn');
                const topologyInput = document.getElementById('topology-input');
                const loadTopologyBtn = document.getElementById('load-topology-btn');

                this.stepInput = stepInput;
                this.jumpButton = jumpBtn;

                prevBtn.addEventListener('click', () => {
                    if (this.currentStep > 0) {
                        this.currentStep--;
                        this.updateVisualization(this.currentStep);
                    }
                });

                nextBtn.addEventListener('click', () => {
                    const data = this.dataManager.getData();
                    if (this.currentStep < data.length - 1) {
                        this.currentStep++;
                        this.updateVisualization(this.currentStep);
                    }
                });

                playPauseBtn.addEventListener('click', () => {
                    if (this.isPlaying) {
                        this.pausePlayback();
                    } else {
                        this.startPlayback();
                    }
                });

                speedSelect.addEventListener('change', (e) => {
                    this.speedFactor = parseFloat(e.target.value) || 1;
                    if (this.isPlaying) {
                        // Restart playback to apply new speed
                        this.pausePlayback();
                        this.startPlayback();
                    }
                });

                if (labelToggle) {
                    this.networkVis.setShowLabels(labelToggle.checked);
                    labelToggle.addEventListener('change', (e) => {
                        this.networkVis.setShowLabels(e.target.checked);
                    });
                }
                if (activeOnlyToggle) {
                    this.networkVis.setShowOnlyActive(activeOnlyToggle.checked);
                    activeOnlyToggle.addEventListener('change', (e) => {
                        this.networkVis.setShowOnlyActive(e.target.checked);
                    });
                }
                if (fadeEdgesToggle) {
                    this.networkVis.setFadeInactiveEdges(fadeEdgesToggle.checked);
                    fadeEdgesToggle.addEventListener('change', (e) => {
                        this.networkVis.setFadeInactiveEdges(e.target.checked);
                    });
                }
                if (highlightPathToggle) {
                    this.networkVis.setHighlightActivePath(highlightPathToggle.checked);
                    highlightPathToggle.addEventListener('change', (e) => {
                        this.networkVis.setHighlightActivePath(e.target.checked);
                    });
                }
                if (pathOnlyToggle) {
                    this.networkVis.setPathOnlyEdges(pathOnlyToggle.checked);
                    pathOnlyToggle.addEventListener('change', (e) => {
                        this.networkVis.setPathOnlyEdges(e.target.checked);
                    });
                }
                if (smallNodesToggle) {
                    this.networkVis.setSmallNodes(smallNodesToggle.checked);
                    smallNodesToggle.addEventListener('change', (e) => {
                        this.networkVis.setSmallNodes(e.target.checked);
                    });
                }
                if (changedOnlyToggle) {
                    this.networkVis.setShowOnlyChanged(changedOnlyToggle.checked);
                    changedOnlyToggle.addEventListener('change', (e) => {
                        this.networkVis.setShowOnlyChanged(e.target.checked);
                    });
                }
                if (layoutModeSelect) {
                    this.networkVis.setLayoutMode(layoutModeSelect.value);
                    layoutModeSelect.addEventListener('change', (e) => {
                        this.networkVis.setLayoutMode(e.target.value);
                    });
                }
                if (bindingsToggle) {
                    this.chessBoard.setBindingsEnabled(bindingsToggle.checked);
                    bindingsToggle.addEventListener('change', (e) => {
                        this.chessBoard.setBindingsEnabled(e.target.checked);
                    });
                }

                const compactToggle = document.getElementById('toggle-compact');
                if (compactToggle) {
                    this.networkVis.setCompact(compactToggle.checked);
                    compactToggle.addEventListener('change', (e) => {
                        this.networkVis.setCompact(e.target.checked);
                    });
                }

                const handleJump = () => {
                    if (!this.stepInput) return;
                    const target = parseInt(this.stepInput.value, 10);
                    if (Number.isNaN(target)) return;
                    this.jumpToStep(target - 1);
                };

                if (stepInput) {
                    stepInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            handleJump();
                        }
                    });
                }

                if (jumpBtn) {
                    jumpBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        handleJump();
                    });
                }

                prevMoveBtn.addEventListener('click', () => {
                    if (!this.moveSteps.length) return;
                    // find the previous move index strictly less than currentStep
                    let idx = this.moveSteps.findIndex(i => i >= this.currentStep);
                    const prevIdx = (idx <= 0) ? -1 : this.moveSteps[idx - 1];
                    const target = (idx === -1) ? this.moveSteps[this.moveSteps.length - 1] : prevIdx;
                    if (target !== -1 && target !== undefined) {
                        this.currentStep = target;
                        this.updateVisualization(this.currentStep);
                    }
                });

                nextMoveBtn.addEventListener('click', () => {
                    if (!this.moveSteps.length) return;
                    let idx = this.moveSteps.findIndex(i => i > this.currentStep);
                    if (idx === -1) return;
                    this.currentStep = this.moveSteps[idx];
                    this.updateVisualization(this.currentStep);
                });

                this.updateControls();
            }

            jumpToStep(stepIndex) {
                const data = this.dataManager.getData();
                if (!data || !data.length) return;
                const clamped = Math.max(0, Math.min(stepIndex, data.length - 1));
                this.pausePlayback();
                this.currentStep = clamped;
                this.updateVisualization(this.currentStep);
            }

            // Start playback
            startPlayback() {
                this.isPlaying = true;
                document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-pause"></i> Pause';

                const intervalMs = Math.max(50, 1000 / this.speedFactor);
                this.playInterval = setInterval(() => {
                    const data = this.dataManager.getData();
                    if (this.currentStep >= data.length - 1) {
                        this.pausePlayback();
                        return;
                    }
                    this.currentStep++;
                    this.updateVisualization(this.currentStep);
                }, intervalMs);
            }

            // Pause playback
            pausePlayback() {
                this.isPlaying = false;
                document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-play"></i> Play';
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }

            // Update controls state
            updateControls() {
                const data = this.dataManager.getData();
                const prevBtn = document.getElementById('prev-btn');
                const nextBtn = document.getElementById('next-btn');
                const prevMoveBtn = document.getElementById('prev-move-btn');
                const nextMoveBtn = document.getElementById('next-move-btn');
                const stepCounter = document.getElementById('step-counter');

                prevBtn.disabled = this.currentStep <= 0;
                nextBtn.disabled = this.currentStep >= data.length - 1;
                prevMoveBtn.disabled = this.moveSteps.length === 0 || this.currentStep <= (this.moveSteps[0] || 0);
                nextMoveBtn.disabled = this.moveSteps.length === 0 || this.currentStep >= (this.moveSteps[this.moveSteps.length - 1] || 0);

                const total = data.length;
                stepCounter.textContent = `Step ${this.currentStep + 1} / ${total}`;

                if (this.stepInput) {
                    if (total > 0) {
                        this.stepInput.disabled = false;
                        this.stepInput.min = 1;
                        this.stepInput.max = total;
                        this.stepInput.value = this.currentStep + 1;
                    } else {
                        this.stepInput.disabled = true;
                        this.stepInput.value = '';
                    }
                }
                if (this.jumpButton) {
                    this.jumpButton.disabled = total === 0;
                }
            }

            // Update visualization for given step
            updateVisualization(step) {
                const data = this.dataManager.getData();
                console.log(`Updating visualization for step ${step}`);
                if (step >= data.length) {
                    console.log(`Step ${step} is beyond data length ${data.length}`);
                    return;
                }

                const frame = data[step];
                console.log('Frame data:', frame);

                // Update chess board (supports both FEN and move-based formats)
                if (frame.env) {
                    this.chessBoard.render(frame.env);

                    // Show position info (enhanced for interactive games)
                    let positionInfo = "";
                    if (frame.env.move_number !== undefined) {
                        positionInfo = `Move ${frame.env.move_number}`;
                        const reconMove = frame.env.recons_move || frame.env.chosen_move;
                        const oppMove = frame.env.opponents_move || frame.env.opponent_move;
                        if (reconMove) {
                            positionInfo += ` - ReCoN: ${reconMove}`;
                        } else if (oppMove) {
                            positionInfo += ` - Opponent: ${oppMove}`;
                        } else if (frame.env.evaluation_tick) {
                            positionInfo += ` - Evaluation tick ${frame.env.evaluation_tick}`;
                        }
                    } else if (frame.env.moves && frame.env.moves.length > 0) {
                        positionInfo = `Moves: ${frame.env.moves.length}`;
                    } else if (frame.env.fen) {
                        positionInfo = `Position: ${frame.env.fen.substring(0, 20)}...`;
                    }
                    document.getElementById('chess-info').textContent = positionInfo;
                }

                // Update thoughts (if panel exists)
                if (frame.thoughts) {
                    const thoughtsEl = document.getElementById('thoughts-text');
                    if (thoughtsEl) {
                        thoughtsEl.textContent = frame.thoughts;
                    }
                }

                const rationaleEl = document.getElementById('rationale-ribbon');
                if (rationaleEl) {
                    const reason = frame.env && (frame.env.last_reason || frame.env.reason);
                    if (reason) {
                        rationaleEl.textContent = `Rationale: ${reason}`;
                        rationaleEl.style.display = 'block';
                    } else {
                        rationaleEl.textContent = '';
                        rationaleEl.style.display = 'none';
                    }
                }

                // Ensure we always have node state data
                const nodeStates = (frame.nodes && Object.keys(frame.nodes).length)
                    ? frame.nodes
                    : this.networkVis.lastNodesState;

                this.networkVis.updateTransitionSet(nodeStates || {});
                const frameWithNodes = Object.assign({}, frame, nodeStates ? { nodes: nodeStates } : {});
                this.networkVis.draw(frameWithNodes, new Set((frame && frame.new_requests) ? frame.new_requests : []));

                // Build or update move index (once)
                if (!this.moveSteps.length) {
                    this.moveSteps = [];
                    data.forEach((f, i) => {
                        const env = f.env || {};
                        const hasMove = !!(env.recons_move || env.chosen_move || env.opponents_move || env.opponent_move);
                        if (hasMove) this.moveSteps.push(i);
                    });
                }

                // Update phase states
                this.updatePhaseStates(nodeStates || {});
                this.updateMacroSummary(frame.macro_frame);

                // Update controls
                this.updateControls();
            }

            // Update phase states in the UI
            updatePhaseStates(nodes) {
                const phaseElements = document.querySelectorAll('.phase-item');

                // Normalize ids from basic/top-level schema to shared schema
                const idMap = {
                    ROOT: 'krk_root',
                    PHASE1: 'phase1_drive_to_edge',
                    PHASE2: 'phase2_shrink_box',
                    PHASE3: 'phase3_take_opposition',
                    PHASE4: 'phase4_deliver_mate'
                };
                const norm = {};
                Object.entries(nodes || {}).forEach(([k,v]) => {
                    norm[idMap[k] || k] = v;
                });

                phaseElements.forEach(element => {
                    const phaseId = element.getAttribute('data-phase');
                    const state = norm[phaseId] || 'INACTIVE';
                    const stateClass = `state-${state.toLowerCase()}`;

                    // Remove all state classes
                    element.className = 'phase-item';

                    // Add current state class
                    element.classList.add(stateClass);
                });
            }

            updateMacroSummary(macro) {
                const container = document.getElementById('macro-summary');
                const linesEl = document.getElementById('macro-lines');
                if (!container || !linesEl) return;
                if (!macro) {
                    container.style.display = 'none';
                    linesEl.textContent = '';
                    return;
                }

                const goalVector = macro.goal_vector || {};
                const goalEntries = Object.entries(goalVector)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 4)
                    .map(([k, v]) => `${k}: ${(v * 100).toFixed(0)}%`)
                    .join(' · ');

                const phaseMix = macro.phase_mix || {};
                const phaseEntries = Object.entries(phaseMix)
                    .map(([k, v]) => `${k}: ${(v * 100).toFixed(0)}%`)
                    .join(' · ');

                const planGroups = (macro.plan_groups || []).map((group) => {
                    const activation = Math.max(0, Math.min(100, Math.round((group.activation || 0) * 100)));
                    const details = (group.details || group.plans || []).map((item) => {
                        const name = item.name || item;
                        const highlight = item.highlight ? ' macro-pill highlight' : ' macro-pill';
                        return `<span class="${highlight.trim()}">${name}</span>`;
                    }).join('');
                    const barWidth = activation;
                    return `
                        <div class="macro-block">
                            <div class="macro-block-header">
                                <span>${group.id}</span>
                                <span>${activation}%</span>
                            </div>
                            <div class="macro-bar"><div class="macro-bar-fill" style="width:${barWidth}%"></div></div>
                            <div class="macro-block-list">${details || '<span class="macro-empty">No plans</span>'}</div>
                        </div>
                    `;
                }).join('');

                const featureGroups = (macro.feature_groups || []).map((group) => {
                    const confidence = Math.max(0, Math.min(100, Math.round((group.confidence || 0) * 100)));
                    const details = (group.details || group.features || []).map((item) => {
                        const name = item.name || item;
                        const highlight = item.highlight ? ' macro-pill highlight' : ' macro-pill';
                        return `<span class="${highlight.trim()}">${name}</span>`;
                    }).join('');
                    return `
                        <div class="macro-block">
                            <div class="macro-block-header">
                                <span>${group.id}</span>
                                <span>${confidence}%</span>
                            </div>
                            <div class="macro-bar"><div class="macro-bar-fill" style="width:${confidence}%"></div></div>
                            <div class="macro-block-list">${details || '<span class="macro-empty">No features</span>'}</div>
                        </div>
                    `;
                }).join('');

                const chosen = macro.move_synth && macro.move_synth.chosen
                    ? macro.move_synth.chosen
                    : '—';

                const components = macro.move_synth && macro.move_synth.proposals && macro.move_synth.proposals[0]
                    ? macro.move_synth.proposals[0].components || {}
                    : {};
                const componentText = Object.entries(components)
                    .map(([k, v]) => `${k}:${(v * 100).toFixed(0)}%`)
                    .join(' ');

                linesEl.innerHTML = `
                    <div><strong>Goals:</strong> ${goalEntries || '—'}</div>
                    <div><strong>Phases:</strong> ${phaseEntries || '—'}</div>
                    <div><strong>Chosen Move:</strong> ${chosen}</div>
                    <div><strong>Move components:</strong> ${componentText || '—'}</div>
                    <div class="macro-section-title">Plan Groups</div>
                    ${planGroups || '<div class="macro-empty">No plan data</div>'}
                    <div class="macro-section-title">Feature Groups</div>
                    ${featureGroups || '<div class="macro-empty">No feature data</div>'}
                `;
                container.style.display = 'block';
            }
        }

        // Global application instance
        let app;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async () => {
            app = new ReConVisualization();
            await app.init();

            // Show initial state immediately
            const data = app.dataManager.getData();
            if (data.length > 0) {
                app.updateVisualization(0);
            }
        });

        // Allow manual loading of a JSON file
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('file-input');
            const btn = document.getElementById('load-file-btn');
            const topologyInput = document.getElementById('topology-input');
            const topologyBtn = document.getElementById('load-topology-btn');
            if (btn && input) {
                btn.addEventListener('click', async () => {
                    const file = input.files && input.files[0];
                    if (!file) return;
                    try {
                        const data = await app.dataManager.loadFromFile(file);
                        app.currentStep = 0;
                        app.moveSteps = []; // Reset move index
                        app.updateControls();
                        app.updateVisualization(0);
                    } catch (e) {
                        console.error('Failed to load JSON file:', e);
                    }
                });
            }
            if (topologyBtn && topologyInput) {
                topologyBtn.addEventListener('click', async () => {
                    const file = topologyInput.files && topologyInput.files[0];
                    if (!file) return;
                    try {
                        const topo = await app.dataManager.loadTopologyFromFile(file);
                        if (topo) {
                            app.networkVis.setTemplateGraph(topo);
                            app.updateVisualization(app.currentStep);
                        }
                    } catch (e) {
                        console.error('Failed to load topology JSON file:', e);
                    }
                });
            }
        });
    </script>
</body>
</html>
