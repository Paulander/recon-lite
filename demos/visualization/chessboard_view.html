<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReCoN KRK Checkmate Visualization</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="header">
        <h1><i class="fas fa-chess-rook"></i> ReCoN KRK Checkmate Visualization</h1>
        <div id="game-info" style="font-size: 0.8em; color: rgba(255,255,255,0.8); margin-top: 5px;">
            Loading visualization data...
        </div>
    </div>

    <div class="main-content">
        <!-- Left Panel -->
        <div class="left-panel">
            <!-- Chess Board -->
            <div class="chess-container">
                <div class="chess-board" id="chess-board"></div>
                <div class="chess-info" id="chess-info">Loading position...</div>
            </div>

            <!-- AI Portrait & Thoughts -->
            <div class="ai-panel">
                <div class="ai-portrait">
                    <i class="fas fa-brain"></i>
                </div>
                <div class="thoughts-container">
                    <div class="thoughts-label">AI Thoughts:</div>
                    <div class="thoughts-text" id="thoughts-text">Initializing ReCoN network...</div>
                </div>
            </div>

            <!-- Phase Schematic -->
            <div class="phase-container">
                <div class="phase-title"><i class="fas fa-layer-group"></i> KRK Checkmate Phases</div>
                <div class="phases-grid" id="phases-grid">
                    <div class="phase-item state-inactive" data-phase="krk_root">ROOT: KRK Checkmate</div>
                    <div class="phase-item state-inactive" data-phase="phase1_drive_to_edge">PHASE1: Drive to Edge</div>
                    <div class="phase-item state-inactive" data-phase="phase2_shrink_box">PHASE2: Shrink Box</div>
                    <div class="phase-item state-inactive" data-phase="phase3_take_opposition">PHASE3: Take Opposition</div>
                    <div class="phase-item state-inactive" data-phase="phase4_deliver_mate">PHASE4: Deliver Mate</div>
                    <div class="phase-item state-inactive" data-phase="king_at_edge">King at Edge?</div>
                    <div class="phase-item state-inactive" data-phase="box_can_shrink">Box Shrink Possible?</div>
                    <div class="phase-item state-inactive" data-phase="can_take_opposition">Has Opposition?</div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <!-- ReCoN Network -->
            <div class="network-container">
                <div class="network-header">
                    <div class="network-title"><i class="fas fa-project-diagram"></i> ReCoN Network</div>
                    <div class="network-legend">
                        <span class="state-inactive">Inactive</span>
                        <span class="state-requested">Requested</span>
                        <span class="state-active">Active</span>
                        <span class="state-suppressed">Suppressed</span>
                        <span class="state-waiting">Waiting</span>
                        <span class="state-true">True</span>
                        <span class="state-confirmed">Confirmed</span>
                        <span class="state-failed">Failed</span>
                    </div>
                </div>
                <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px; flex-wrap: wrap;">
                    <input type="file" id="file-input" accept="application/json" />
                    <button class="control-btn" id="load-file-btn">Load JSON</button>
                    <div style="display:flex; align-items:center; gap:6px;">
                        <span style="font-size:12px;color:#555;">Speed</span>
                        <select id="speed-select" class="control-btn" style="padding:6px 10px; background:#fff; color:#333; border:1px solid #ddd;">
                            <option value="1">1x</option>
                            <option value="2">2x</option>
                            <option value="4">4x</option>
                        </select>
                    </div>
                    <div style="font-size:12px;color:#555;">Shape: sensors = ◇, others = ●</div>
                    <label for="toggle-labels" class="label-toggle">
                        <input type="checkbox" id="toggle-labels" checked>
                        <span>Show labels</span>
                    </label>
                </div>
                <canvas id="network-canvas" style="flex: 1; border-radius: 8px; background: #f8f9fa;"></canvas>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn" id="prev-btn" disabled>
            <i class="fas fa-step-backward"></i> Previous
        </button>
        <button class="control-btn" id="play-pause-btn">
            <i class="fas fa-play"></i> Play
        </button>
        <button class="control-btn" id="next-btn" disabled>
            Next <i class="fas fa-step-forward"></i>
        </button>
        <button class="control-btn" id="prev-move-btn" disabled>
            <i class="fas fa-backward"></i> Prev Move
        </button>
        <button class="control-btn" id="next-move-btn" disabled>
            Next Move <i class="fas fa-forward"></i>
        </button>
        <div class="step-counter" id="step-counter">Step 0 / 0</div>
    </div>

    <script src="data-manager.js"></script>
    <script src="chess-board.js"></script>
    <script src="network-visualization.js"></script>
    <script>
        // Main application controller
        // Coordinates between the different visualization modules

        class ReConVisualization {
            constructor() {
                this.currentStep = 0;
                this.isPlaying = false;
                this.playInterval = null;
                this.speedFactor = 1;
                this.moveSteps = []; // indices where a move was applied/logged

                // Initialize modules
                this.dataManager = new DataManager();
                this.chessBoard = new ChessBoard();
                this.networkVis = new NetworkVisualization();
            }

            async init() {
                console.log('Initializing ReCoN visualization...');

                try {
                    // Initialize chess board first (show placeholder)
                    this.chessBoard.init();

                    // Initialize network visualization
                    this.networkVis.init();

                    // Setup controls
                    this.setupControls();

                    // Load visualization data (this will show initial state)
                    await this.dataManager.loadVisualizationData();

                    // Set external edges if available
                    const externalEdges = this.dataManager.getExternalEdges();
                    if (externalEdges) {
                        this.networkVis.setExternalEdges(externalEdges);
                    }

                    console.log('ReCoN visualization initialized successfully');

                } catch (error) {
                    console.error('Error initializing application:', error);
                    document.getElementById('thoughts-text').textContent = 'Error initializing visualization';
                }
            }

            // Setup controls
            setupControls() {
                const prevBtn = document.getElementById('prev-btn');
                const nextBtn = document.getElementById('next-btn');
                const playPauseBtn = document.getElementById('play-pause-btn');
                const speedSelect = document.getElementById('speed-select');
                const prevMoveBtn = document.getElementById('prev-move-btn');
                const nextMoveBtn = document.getElementById('next-move-btn');
                const labelToggle = document.getElementById('toggle-labels');

                prevBtn.addEventListener('click', () => {
                    if (this.currentStep > 0) {
                        this.currentStep--;
                        this.updateVisualization(this.currentStep);
                    }
                });

                nextBtn.addEventListener('click', () => {
                    const data = this.dataManager.getData();
                    if (this.currentStep < data.length - 1) {
                        this.currentStep++;
                        this.updateVisualization(this.currentStep);
                    }
                });

                playPauseBtn.addEventListener('click', () => {
                    if (this.isPlaying) {
                        this.pausePlayback();
                    } else {
                        this.startPlayback();
                    }
                });

                speedSelect.addEventListener('change', (e) => {
                    this.speedFactor = parseFloat(e.target.value) || 1;
                    if (this.isPlaying) {
                        // Restart playback to apply new speed
                        this.pausePlayback();
                        this.startPlayback();
                    }
                });

                if (labelToggle) {
                    this.networkVis.setShowLabels(labelToggle.checked);
                    labelToggle.addEventListener('change', (e) => {
                        this.networkVis.setShowLabels(e.target.checked);
                    });
                }

                prevMoveBtn.addEventListener('click', () => {
                    if (!this.moveSteps.length) return;
                    // find the previous move index strictly less than currentStep
                    let idx = this.moveSteps.findIndex(i => i >= this.currentStep);
                    const prevIdx = (idx <= 0) ? -1 : this.moveSteps[idx - 1];
                    const target = (idx === -1) ? this.moveSteps[this.moveSteps.length - 1] : prevIdx;
                    if (target !== -1 && target !== undefined) {
                        this.currentStep = target;
                        this.updateVisualization(this.currentStep);
                    }
                });

                nextMoveBtn.addEventListener('click', () => {
                    if (!this.moveSteps.length) return;
                    let idx = this.moveSteps.findIndex(i => i > this.currentStep);
                    if (idx === -1) return;
                    this.currentStep = this.moveSteps[idx];
                    this.updateVisualization(this.currentStep);
                });

                this.updateControls();
            }

            // Start playback
            startPlayback() {
                this.isPlaying = true;
                document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-pause"></i> Pause';

                const intervalMs = Math.max(50, 1000 / this.speedFactor);
                this.playInterval = setInterval(() => {
                    const data = this.dataManager.getData();
                    if (this.currentStep >= data.length - 1) {
                        this.pausePlayback();
                        return;
                    }
                    this.currentStep++;
                    this.updateVisualization(this.currentStep);
                }, intervalMs);
            }

            // Pause playback
            pausePlayback() {
                this.isPlaying = false;
                document.getElementById('play-pause-btn').innerHTML = '<i class="fas fa-play"></i> Play';
                if (this.playInterval) {
                    clearInterval(this.playInterval);
                    this.playInterval = null;
                }
            }

            // Update controls state
            updateControls() {
                const data = this.dataManager.getData();
                const prevBtn = document.getElementById('prev-btn');
                const nextBtn = document.getElementById('next-btn');
                const prevMoveBtn = document.getElementById('prev-move-btn');
                const nextMoveBtn = document.getElementById('next-move-btn');
                const stepCounter = document.getElementById('step-counter');

                prevBtn.disabled = this.currentStep <= 0;
                nextBtn.disabled = this.currentStep >= data.length - 1;
                prevMoveBtn.disabled = this.moveSteps.length === 0 || this.currentStep <= (this.moveSteps[0] || 0);
                nextMoveBtn.disabled = this.moveSteps.length === 0 || this.currentStep >= (this.moveSteps[this.moveSteps.length - 1] || 0);

                const total = data.length;
                stepCounter.textContent = `Step ${this.currentStep + 1} / ${total}`;
            }

            // Update visualization for given step
            updateVisualization(step) {
                const data = this.dataManager.getData();
                console.log(`Updating visualization for step ${step}`);
                if (step >= data.length) {
                    console.log(`Step ${step} is beyond data length ${data.length}`);
                    return;
                }

                const frame = data[step];
                console.log('Frame data:', frame);

                // Update chess board (supports both FEN and move-based formats)
                if (frame.env) {
                    this.chessBoard.render(frame.env);

                    // Show position info (enhanced for interactive games)
                    let positionInfo = "";
                    if (frame.env.move_number !== undefined) {
                        positionInfo = `Move ${frame.env.move_number}`;
                        const reconMove = frame.env.recons_move || frame.env.chosen_move;
                        const oppMove = frame.env.opponents_move || frame.env.opponent_move;
                        if (reconMove) {
                            positionInfo += ` - ReCoN: ${reconMove}`;
                        } else if (oppMove) {
                            positionInfo += ` - Opponent: ${oppMove}`;
                        } else if (frame.env.evaluation_tick) {
                            positionInfo += ` - Evaluation tick ${frame.env.evaluation_tick}`;
                        }
                    } else if (frame.env.moves && frame.env.moves.length > 0) {
                        positionInfo = `Moves: ${frame.env.moves.length}`;
                    } else if (frame.env.fen) {
                        positionInfo = `Position: ${frame.env.fen.substring(0, 20)}...`;
                    }
                    document.getElementById('chess-info').textContent = positionInfo;
                }

                // Update thoughts
                if (frame.thoughts) {
                    document.getElementById('thoughts-text').textContent = frame.thoughts;
                }

                // Ensure we always have node state data
                const nodeStates = (frame.nodes && Object.keys(frame.nodes).length)
                    ? frame.nodes
                    : this.networkVis.lastNodesState;

                this.networkVis.updateTransitionSet(nodeStates || {});
                const frameWithNodes = Object.assign({}, frame, nodeStates ? { nodes: nodeStates } : {});
                this.networkVis.draw(frameWithNodes, new Set((frame && frame.new_requests) ? frame.new_requests : []));

                // Build or update move index (once)
                if (!this.moveSteps.length) {
                    this.moveSteps = [];
                    data.forEach((f, i) => {
                        const env = f.env || {};
                        const hasMove = !!(env.recons_move || env.chosen_move || env.opponents_move || env.opponent_move);
                        if (hasMove) this.moveSteps.push(i);
                    });
                }

                // Update phase states
                this.updatePhaseStates(nodeStates || {});

                // Update controls
                this.updateControls();
            }

            // Update phase states in the UI
            updatePhaseStates(nodes) {
                const phaseElements = document.querySelectorAll('.phase-item');

                // Normalize ids from basic/top-level schema to shared schema
                const idMap = {
                    ROOT: 'krk_root',
                    PHASE1: 'phase1_drive_to_edge',
                    PHASE2: 'phase2_shrink_box',
                    PHASE3: 'phase3_take_opposition',
                    PHASE4: 'phase4_deliver_mate'
                };
                const norm = {};
                Object.entries(nodes || {}).forEach(([k,v]) => {
                    norm[idMap[k] || k] = v;
                });

                phaseElements.forEach(element => {
                    const phaseId = element.getAttribute('data-phase');
                    const state = norm[phaseId] || 'INACTIVE';
                    const stateClass = `state-${state.toLowerCase()}`;

                    // Remove all state classes
                    element.className = 'phase-item';

                    // Add current state class
                    element.classList.add(stateClass);
                });
            }
        }

        // Global application instance
        let app;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', async () => {
            app = new ReConVisualization();
            await app.init();

            // Show initial state immediately
            const data = app.dataManager.getData();
            if (data.length > 0) {
                app.updateVisualization(0);
            }
        });

        // Allow manual loading of a JSON file
        document.addEventListener('DOMContentLoaded', () => {
            const input = document.getElementById('file-input');
            const btn = document.getElementById('load-file-btn');
            if (btn && input) {
                btn.addEventListener('click', async () => {
                    const file = input.files && input.files[0];
                    if (!file) return;
                    try {
                        const data = await app.dataManager.loadFromFile(file);
                        app.currentStep = 0;
                        app.moveSteps = []; // Reset move index
                        app.updateControls();
                        app.updateVisualization(0);
                    } catch (e) {
                        console.error('Failed to load JSON file:', e);
                    }
                });
            }
        });
    </script>
</body>
</html>
