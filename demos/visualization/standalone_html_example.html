<!-- demos/visualization/index.html 
 Hardcoded visualization for the sequence demo (for now)

 TODO: 
 - Let it import json files instead of hardcoding
 - make sure it supports (somewhat) arbitrary ReCoN graphs. 
 - (optional) Visual improvements - OSKAR: DO NOT GET STUCK ON THIS. SOLVE THE MAIN PROBLEM FIRST.

-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ReCoN Visualization Demo - Enhanced</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        #panel {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            max-width: 300px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.5);
            z-index: 100;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
        }
        #slider {
            width: 300px;
            margin-right: 10px;
        }
        #fileInput {
            margin-bottom: 10px;
        }
        button {
            background: #4169E1;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 2px;
        }
        button:hover { background: #365899; }
        input[type="checkbox"] { margin-right: 5px; }
        h3 { margin: 0 0 10px 0; color: #00FF00; }
        #legend {
            margin-top: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 4px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        #toggleLegend {
            background: #228B22;
        }
        #viewToggle {
            background: #FF8C00;
        }
    </style>
</head>
<body>
    <div id="panel">
        <h3>Tick 0</h3>
        <p id="note">start</p>
        <p id="thoughts">Initiate ROOT</p>
        <div>
            <label><input type="checkbox" id="nodeLabels" checked> Node Labels</label><br>
            <label><input type="checkbox" id="edgeLabels"> Edge Labels</label>
        </div>
        <button id="toggleLegend">Toggle Legend</button>
        <div id="legend" style="display: block;">
            <div class="legend-item"><div class="legend-color" style="background: #888888;"></div>Inactive</div>
            <div class="legend-item"><div class="legend-color" style="background: #4169E1;"></div>Requested</div>
            <div class="legend-item"><div class="legend-color" style="background: #FF8C00;"></div>Waiting</div>
            <div class="legend-item"><div class="legend-color" style="background: #32CD32;"></div>True</div>
            <div class="legend-item"><div class="legend-color" style="background: #228B22;"></div>Confirmed</div>
            <div class="legend-item"><div class="legend-color" style="background: #FF0000;"></div>Failed</div>
        </div>
    </div>
    <div id="controls">
        <input type="file" id="fileInput" accept=".json" style="margin-bottom: 10px;">
        <button id="viewToggle">Switch to Simple View</button>
        <input type="range" id="slider" min="0" max="14" value="0" step="1">
        <button id="play">Play</button>
    </div>

    <script>
        // Default embedded JSON (for demo without file)
        let frames = [
  {
    "type": "snapshot",
    "tick": 0,
    "note": "start",
    "nodes": {
      "ROOT": "REQUESTED",
      "A": "INACTIVE",
      "B1": "INACTIVE",
      "B2": "INACTIVE",
      "C": "INACTIVE",
      "A_done": "INACTIVE",
      "B1_done": "INACTIVE",
      "B2_done": "INACTIVE",
      "C_done": "INACTIVE"
    },
    "env": {},
    "thoughts": "Initiate ROOT"
  },
  {
    "type": "snapshot",
    "tick": 1,
    "note": "tick 1",
    "nodes": {
      "ROOT": "WAITING",
      "A": "WAITING",
      "B1": "INACTIVE",
      "B2": "INACTIVE",
      "C": "INACTIVE",
      "A_done": "REQUESTED",
      "B1_done": "INACTIVE",
      "B2_done": "INACTIVE",
      "C_done": "INACTIVE"
    },
    "new_requests": [
      "A",
      "A_done"
    ],
    "env": {},
    "thoughts": "tick 1: requested ['A', 'A_done']"
  },
  {
    "type": "snapshot",
    "tick": 2,
    "note": "tick 2",
    "nodes": {
      "ROOT": "WAITING",
      "A": "WAITING",
      "B1": "INACTIVE",
      "B2": "INACTIVE",
      "C": "INACTIVE",
      "A_done": "WAITING",
      "B1_done": "INACTIVE",
      "B2_done": "INACTIVE",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 2: requested []"
  },
  {
    "type": "snapshot",
    "tick": 3,
    "note": "tick 3",
    "nodes": {
      "ROOT": "WAITING",
      "A": "WAITING",
      "B1": "INACTIVE",
      "B2": "INACTIVE",
      "C": "INACTIVE",
      "A_done": "TRUE",
      "B1_done": "INACTIVE",
      "B2_done": "INACTIVE",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 3: requested []"
  },
  {
    "type": "snapshot",
    "tick": 4,
    "note": "tick 4",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "INACTIVE",
      "B2": "INACTIVE",
      "C": "INACTIVE",
      "A_done": "CONFIRMED",
      "B1_done": "INACTIVE",
      "B2_done": "INACTIVE",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 4: requested []"
  },
  {
    "type": "snapshot",
    "tick": 5,
    "note": "tick 5",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "WAITING",
      "B2": "WAITING",
      "C": "INACTIVE",
      "A_done": "CONFIRMED",
      "B1_done": "REQUESTED",
      "B2_done": "REQUESTED",
      "C_done": "INACTIVE"
    },
    "new_requests": [
      "B1",
      "B2",
      "B1_done",
      "B2_done"
    ],
    "env": {},
    "thoughts": "tick 5: requested ['B1', 'B2', 'B1_done', 'B2_done']"
  },
  {
    "type": "snapshot",
    "tick": 6,
    "note": "tick 6",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "WAITING",
      "B2": "WAITING",
      "C": "INACTIVE",
      "A_done": "CONFIRMED",
      "B1_done": "WAITING",
      "B2_done": "WAITING",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 6: requested []"
  },
  {
    "type": "snapshot",
    "tick": 7,
    "note": "tick 7",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "WAITING",
      "B2": "WAITING",
      "C": "INACTIVE",
      "A_done": "CONFIRMED",
      "B1_done": "WAITING",
      "B2_done": "TRUE",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 7: requested []"
  },
  {
    "type": "snapshot",
    "tick": 8,
    "note": "tick 8",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "WAITING",
      "B2": "CONFIRMED",
      "C": "INACTIVE",
      "A_done": "CONFIRMED",
      "B1_done": "TRUE",
      "B2_done": "CONFIRMED",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 8: requested []"
  },
  {
    "type": "snapshot",
    "tick": 9,
    "note": "tick 9",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "CONFIRMED",
      "B2": "CONFIRMED",
      "C": "INACTIVE",
      "A_done": "CONFIRMED",
      "B1_done": "CONFIRMED",
      "B2_done": "CONFIRMED",
      "C_done": "INACTIVE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 9: requested []"
  },
  {
    "type": "snapshot",
    "tick": 10,
    "note": "tick 10",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "CONFIRMED",
      "B2": "CONFIRMED",
      "C": "WAITING",
      "A_done": "CONFIRMED",
      "B1_done": "CONFIRMED",
      "B2_done": "CONFIRMED",
      "C_done": "REQUESTED"
    },
    "new_requests": [
      "C",
      "C_done"
    ],
    "env": {},
    "thoughts": "tick 10: requested ['C', 'C_done']"
  },
  {
    "type": "snapshot",
    "tick": 11,
    "note": "tick 11",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "CONFIRMED",
      "B2": "CONFIRMED",
      "C": "WAITING",
      "A_done": "CONFIRMED",
      "B1_done": "CONFIRMED",
      "B2_done": "CONFIRMED",
      "C_done": "WAITING"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 11: requested []"
  },
  {
    "type": "snapshot",
    "tick": 12,
    "note": "tick 12",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "CONFIRMED",
      "B2": "CONFIRMED",
      "C": "WAITING",
      "A_done": "CONFIRMED",
      "B1_done": "CONFIRMED",
      "B2_done": "CONFIRMED",
      "C_done": "TRUE"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 12: requested []"
  },
  {
    "type": "snapshot",
    "tick": 13,
    "note": "tick 13",
    "nodes": {
      "ROOT": "WAITING",
      "A": "CONFIRMED",
      "B1": "CONFIRMED",
      "B2": "CONFIRMED",
      "C": "CONFIRMED",
      "A_done": "CONFIRMED",
      "B1_done": "CONFIRMED",
      "B2_done": "CONFIRMED",
      "C_done": "CONFIRMED"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 13: requested []"
  },
  {
    "type": "snapshot",
    "tick": 14,
    "note": "tick 14",
    "nodes": {
      "ROOT": "CONFIRMED",
      "A": "CONFIRMED",
      "B1": "CONFIRMED",
      "B2": "CONFIRMED",
      "C": "CONFIRMED",
      "A_done": "CONFIRMED",
      "B1_done": "CONFIRMED",
      "B2_done": "CONFIRMED",
      "C_done": "CONFIRMED"
    },
    "new_requests": [],
    "env": {},
    "thoughts": "tick 14: requested []"
  }
];

        // State colors (hex)
        const stateColors = {
            'INACTIVE': 0x888888,
            'REQUESTED': 0x4169E1,
            'WAITING': 0xFF8C00,
            'TRUE': 0x32CD32,
            'CONFIRMED': 0x228B22,
            'FAILED': 0xFF0000
        };

        // Fixed 3D positions for nodes
        const nodePositions = {
            'ROOT': [0, 5, 0],
            'A': [0, 3, 0],
            'B1': [-2, 1, 0],
            'B2': [2, 1, 0],
            'C': [0, -1, 0],
            'A_done': [0, 2, -1],
            'B1_done': [-2, 0, -1],
            'B2_done': [2, 0, -1],
            'C_done': [0, -2, -1]
        };

        // Edges with labels
        const edges = [
            {from: 'ROOT', to: 'A', type: 'sub', label: 'sub'},
            {from: 'A', to: 'A_done', type: 'sub', label: 'sub'},
            {from: 'B1', to: 'B1_done', type: 'sub', label: 'sub'},
            {from: 'B2', to: 'B2_done', type: 'sub', label: 'sub'},
            {from: 'C', to: 'C_done', type: 'sub', label: 'sub'},
            {from: 'A', to: 'B1', type: 'por', label: 'por'},
            {from: 'A', to: 'B2', type: 'por', label: 'por'},
            {from: 'B1', to: 'C', type: 'por', label: 'por'},
            {from: 'B2', to: 'C', type: 'por', label: 'por'}
        ];

        const nodeIds = Object.keys(nodePositions);

        // Viewing mode: 'advanced' or 'simple'
        let viewingMode = 'advanced';

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // Lighting (toggled in simple mode)
        const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 5, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        const pointLight = new THREE.PointLight(0x00ff00, 0.5, 100);
        pointLight.position.set(0, 0, 5);
        scene.add(pointLight);

        // Node meshes
        const nodeMeshes = {};
        const sphereGeometry = new THREE.SphereGeometry(0.15, 32, 32);
        nodeIds.forEach(id => {
            const material = new THREE.MeshPhongMaterial({
                color: stateColors['INACTIVE'],
                shininess: 100,
                emissive: 0x111111,
                transparent: true,
                opacity: 0.8
            });
            const sphere = new THREE.Mesh(sphereGeometry, material);
            sphere.position.set(...nodePositions[id]);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);
            nodeMeshes[id] = sphere;
        });

        // Edge lines (thicker for clarity)
        const edgeMeshes = [];
        edges.forEach(edge => {
            const points = [
                new THREE.Vector3(...nodePositions[edge.from]),
                new THREE.Vector3(...nodePositions[edge.to])
            ];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: edge.type === 'sub' ? 0x888888 : 0xDAA520,
                linewidth: 5,
                transparent: true,
                opacity: 0.8
            });
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            edgeMeshes.push({ mesh: line, type: edge.type, label: edge.label });
        });

        // Labels
        const nodeLabels = {};
        const edgeLabelMeshes = [];
        function createLabelTexture(text, color = 0xffffff) {
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 256, 64);
            ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 32);
            return new THREE.CanvasTexture(canvas);
        }

        nodeIds.forEach(id => {
            const spriteMaterial = new THREE.SpriteMaterial({
                map: createLabelTexture(id),
                transparent: true,
                opacity: 0.9
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.set(...nodePositions[id]);
            sprite.position.y += 0.3;
            sprite.scale.set(1.5, 0.4, 1);
            scene.add(sprite);
            nodeLabels[id] = sprite;
        });

        edges.forEach((edge, index) => {
            const midPoint = new THREE.Vector3().lerpVectors(
                new THREE.Vector3(...nodePositions[edge.from]),
                new THREE.Vector3(...nodePositions[edge.to]),
                0.5
            );
            const spriteMaterial = new THREE.SpriteMaterial({
                map: createLabelTexture(edge.label, edge.type === 'sub' ? 0x888888 : 0xDAA520),
                transparent: true,
                opacity: 0.8
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.position.copy(midPoint);
            sprite.position.y += 0.1;
            sprite.scale.set(1, 0.3, 1);
            scene.add(sprite);
            edgeLabelMeshes.push(sprite);
        });

        // Label toggles
        document.getElementById('nodeLabels').addEventListener('change', (e) => {
            const visible = e.target.checked;
            Object.values(nodeLabels).forEach(label => label.visible = visible);
        });
        document.getElementById('edgeLabels').addEventListener('change', (e) => {
            const visible = e.target.checked;
            edgeLabelMeshes.forEach(label => label.visible = visible);
        });

        // Particles group (for advanced mode only)
        const particles = new THREE.Group();
        scene.add(particles);
        let activeParticles = {};
        const particleCount = 200;
        function emitParticlesFromNode(nodeId, color) {
            if (activeParticles[nodeId]) {
                activeParticles[nodeId].forEach(p => scene.remove(p));
                delete activeParticles[nodeId];
            }

            const particleGroup = new THREE.Group();
            const positions = new Float32Array(particleCount * 3);
            const velocities = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const sizes = new Float32Array(particleCount);

            for (let i = 0; i < particleCount; i++) {
                const nodePos = new THREE.Vector3(...nodePositions[nodeId]);
                positions[i * 3] = nodePos.x + (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 1] = nodePos.y + (Math.random() - 0.5) * 0.1;
                positions[i * 3 + 2] = nodePos.z + (Math.random() - 0.5) * 0.1;

                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05,
                    (Math.random() - 0.5) * 0.05
                ).normalize().multiplyScalar(0.01 + Math.random() * 0.02);

                velocities[i * 3] = vel.x;
                velocities[i * 3 + 1] = vel.y;
                velocities[i * 3 + 2] = vel.z;

                colors[i * 3] = (color >> 16 & 255) / 255;
                colors[i * 3 + 1] = (color >> 8 & 255) / 255;
                colors[i * 3 + 2] = (color & 255) / 255;

                sizes[i] = Math.random() * 1 + 0.5;
            }

            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 } },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float time;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z) * (1.0 - time * 0.5);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        if (length(gl_PointCoord - vec2(0.5)) > 0.5) discard;
                        gl_FragColor = vec4(vColor, 0.3);
                    }
                `,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true
            });

            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            particleGroup.add(particleSystem);

            scene.add(particleGroup);
            activeParticles[nodeId] = particleGroup.children;

            const startTime = Date.now();
            const animateBurst = () => {
                const elapsed = (Date.now() - startTime) / 1000;
                if (elapsed > 2) {
                    scene.remove(particleGroup);
                    delete activeParticles[nodeId];
                    return;
                }
                particleSystem.material.uniforms.time.value = elapsed;
                requestAnimationFrame(animateBurst);
            };
            animateBurst();
        }

        // Camera setup
        camera.position.set(0, 2, 8);
        camera.lookAt(0, 2, 0);

        // Playback state
        let currentTick = 0;
        let isPlaying = false;
        let playInterval;
        let prevFrame = null;

        function updateVisualization() {
            const frame = frames[currentTick];
            const nodes = frame.nodes;
            const newRequests = frame.new_requests || [];

            // Particles only in advanced mode
            if (viewingMode === 'advanced' && prevFrame) {
                const prevNodes = prevFrame.nodes;
                Object.keys(nodes).forEach(id => {
                    const prevState = prevNodes[id] || 'INACTIVE';
                    const currState = nodes[id] || 'INACTIVE';
                    if (newRequests.includes(id) || currState === 'TRUE' || currState === 'CONFIRMED') {
                        const color = stateColors[currState];
                        emitParticlesFromNode(id, color);
                    }
                });
            }

            // Update nodes
            nodeIds.forEach(id => {
                const state = nodes[id] || 'INACTIVE';
                const color = stateColors[state];
                const mesh = nodeMeshes[id];
                mesh.material.color.setHex(color);
                mesh.material.emissive.setHex(viewingMode === 'advanced' ? color * 0.1 : 0x000000); // No glow in simple
                mesh.material.opacity = viewingMode === 'simple' ? 1.0 : 0.8; // Opaque in simple
                mesh.scale.set(1, 1, 1);
            });

            // Pulse only in advanced
            if (viewingMode === 'advanced') {
                newRequests.forEach(id => {
                    if (nodeMeshes[id]) {
                        nodeMeshes[id].scale.set(1.8, 1.8, 1.8);
                    }
                });
            }

            // Update edges opacity
            edgeMeshes.forEach(({ mesh }) => {
                mesh.material.opacity = viewingMode === 'simple' ? 1.0 : 0.8;
            });

            // Update panel
            document.getElementById('note').textContent = frame.note;
            document.getElementById('thoughts').textContent = frame.thoughts;
            document.querySelector('h3').textContent = `Tick ${frame.tick}`;

            prevFrame = frame;
        }

        function animate() {
            requestAnimationFrame(animate);

            // Rotation only in advanced
            if (viewingMode === 'advanced') {
                scene.rotation.y += 0.002;
            }

            renderer.render(scene, camera);
        }

        animate();

        // Controls
        const slider = document.getElementById('slider');
        slider.max = frames.length - 1;
        slider.oninput = (e) => {
            currentTick = parseInt(e.target.value);
            updateVisualization();
        };

        document.getElementById('play').onclick = () => {
            const btn = document.getElementById('play');
            isPlaying = !isPlaying;
            btn.textContent = isPlaying ? 'Pause' : 'Play';
            btn.style.background = isPlaying ? '#FF8C00' : '#4169E1';

            if (isPlaying) {
                playInterval = setInterval(() => {
                    if (currentTick < frames.length - 1) {
                        currentTick++;
                        slider.value = currentTick;
                        updateVisualization();
                    } else {
                        clearInterval(playInterval);
                        isPlaying = false;
                        btn.textContent = 'Play';
                        btn.style.background = '#4169E1';
                    }
                }, 600);
            } else {
                clearInterval(playInterval);
            }
        };

        // View toggle
        document.getElementById('viewToggle').onclick = () => {
            viewingMode = viewingMode === 'advanced' ? 'simple' : 'advanced';
            const btn = document.getElementById('viewToggle');
            btn.textContent = viewingMode === 'advanced' ? 'Switch to Simple View' : 'Switch to Advanced View';
            btn.style.background = viewingMode === 'advanced' ? '#FF8C00' : '#4169E1';

            // Clear particles in simple mode
            if (viewingMode === 'simple') {
                Object.values(activeParticles).forEach(groupChildren => {
                    groupChildren.forEach(child => scene.remove(child));
                });
                activeParticles = {};
                // Disable shadows for clarity
                renderer.shadowMap.enabled = false;
                nodeMeshes.forEach(mesh => {
                    mesh.castShadow = false;
                    mesh.receiveShadow = false;
                });
                // Switch to orthographic for 2D feel
                const aspect = window.innerWidth / window.innerHeight;
                camera = new THREE.OrthographicCamera(-5 * aspect, 5 * aspect, 5, -5, 0.1, 1000);
                camera.position.set(0, 2, 8);
                camera.lookAt(0, 2, 0);
            } else {
                // Re-enable advanced
                renderer.shadowMap.enabled = true;
                nodeMeshes.forEach(mesh => {
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                });
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.set(0, 2, 8);
                camera.lookAt(0, 2, 0);
            }

            updateVisualization();
        };

        // File import
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    frames = JSON.parse(event.target.result);
                    frames.sort((a, b) => a.tick - b.tick);
                    slider.max = frames.length - 1;
                    currentTick = 0;
                    slider.value = 0;
                    prevFrame = null;
                    updateVisualization();
                };
                reader.readAsText(file);
            }
        });

        // Legend toggle
        document.getElementById('toggleLegend').onclick = () => {
            const legend = document.getElementById('legend');
            legend.style.display = legend.style.display === 'none' ? 'block' : 'none';
        };

        // Initial render
        updateVisualization();

        // Responsive resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Initial label visibility
        Object.values(nodeLabels).forEach(label => label.visible = true);
        edgeLabelMeshes.forEach(label => label.visible = false);
    </script>
</body>
</html>